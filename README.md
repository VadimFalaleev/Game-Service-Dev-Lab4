# Разработка игровых сервисов
Отчет по лабораторной работе #4 выполнил(а):
- Фалалеев Вадим Эдуардович
- РИ-300012

Отметка о выполнении заданий (заполняется студентом):

| Задание | Выполнение | Баллы |
| ------ | ------ | ------ |
| Задание 1 | * | 60 |
| Задание 2 | * | 20 |
| Задание 3 | * | 20 |

знак "*" - задание выполнено; знак "#" - задание не выполнено;

Работу проверили:
- к.т.н., доцент Денисов Д.В.
- к.э.н., доцент Панов М.А.
- ст. преп., Фадеев В.О.

Структура отчета

- Данные о работе: название работы, фио, группа, выполненные задания.
- Цель работы.
- Задание 1.
- Код реализации выполнения задания. Визуализация результатов выполнения (если применимо).
- Задание 2.
- Код реализации выполнения задания. Визуализация результатов выполнения (если применимо).
- Задание 3.
- Код реализации выполнения задания. Визуализация результатов выполнения (если применимо).
- Выводы.

## Цель работы
подготовить разрабатываемое интерактивное приложение к сборке и публикации.

## Задание 1
### Используя видео-материалы практических работ 1-5 повторить реализацию приведенного ниже функционала:
– 1 Практическая работа «Создание анимации объектов на сцене»

– 2 Практическая работа «Создание стартовой сцены и переключение между ними»

– 3 Практическая работа «Доработка меню и функционала с остановкой игры»

– 4 Практическая работа «Добавление звукового сопровождения в игре»

– 5 Практическая работа «Добавление персонажа и сборка сцены для публикации на web-ресурсе»

Ход работы:

- Начнем создавать стартовую сцену при запуске игры. Для этого скопируем нашу сцену и эту копию переименуем в _1Scene. Теперь в _0Scene удалим объект Ground, в объекте Canvas удалим Score. Удалим с объекта Main Camera скрипт Dragon Picker, а с объекта Enemy удалим скрипт Enemy Dragon. Так же изменим значения Position, Rotation и Scale у объектов Enemy и DragonMountain, как показано на скриншотах.

![image](https://user-images.githubusercontent.com/54228342/199060292-ca896375-8697-4e9e-9001-79e477a48d70.png)
![image](https://user-images.githubusercontent.com/54228342/199060315-7b85a815-8783-414f-9f19-f6338f6b15d3.png)

- После этих действий у нас получается следующая сцена.

![image](https://user-images.githubusercontent.com/54228342/199060773-dea8c88d-1098-4bf2-8537-b7e564e5444f.png)

- Далее нужно поработать с анимацией для дракона. В папке _Animations создадим Animator Controller и назовем его DragonIDLE. Добавим в него анимацию idle01, после чего объекту Enemy заменим контроллер на только что созданный.

![image](https://user-images.githubusercontent.com/54228342/199061863-37c1340f-2aa7-4ed9-bad9-dd5c7e0d3a9d.png)

- После этого нам нужно добавить новый ассет "Painted HQ 2D Forest Medieval Background" по той же схеме, что и прошлые. Так же его загружаем в Unity и импортируем в проект.
- В папке Day из этого ассета копируем Cloud02, перемещяем копию в папку _Textures нашего проекта. Затем этот же объект перемещаем на сцену так, чтобы он оказался дочерним объектом у Canvas.
- Наверху слева нажимаем кнопку Window > Animation > Animation. Окно прикрепляем в удобную часть экрана. В самом окне нажимаем кнопку Create, создаем анимацию CloudAnimation в папке _Animations.
- В окне нажимаем Add Property > Transform > Position для того, чтобы менять позицию облака. Переместим последние два ключа на вторую минуту, а на первую изменим позицию облака и добавим ключ. Так мы создаем самую простую анимацию и облако будет летать в одну сторону и возвращаться.

![image](https://user-images.githubusercontent.com/54228342/199066941-8d6e0db9-a4c3-41ad-b1ed-cacde244d65d.png)

- Зайдем в папку с анимациями и изменим скорость анимации облака на 0.1, чтобы оно не передвигалось слишком быстро.

![image](https://user-images.githubusercontent.com/54228342/199067687-7a49e52d-2779-4706-9fa6-4183f4de2103.png)

- Последним действием первого видео является добавление компонента Rect Transform и привязка облака к верхнему правому углу, чтобы при любом разрешении оно было в одном и том же месте на экране.

![image](https://user-images.githubusercontent.com/54228342/199068583-4bd166c8-2d30-497a-9d8f-6e0d05d79328.png)

- Теперь мы можем посмотреть на результаты действий после первого видео.

![Видео 31-10-2022 222536](https://user-images.githubusercontent.com/54228342/199071032-fdb81a33-174b-4822-bb9c-22074cdb0659.gif)

- Во втором видео мы продолжим делать стартовый экран и поработаем с переключением сцен.
- Начнем с показа названия игры. Создадим в Canvas объект Text, назовем его Title. В самом тексте напишем "Dragon picker". Поставим якорь на верхний левый угол и настроим положение объекта на сцене.

![image](https://user-images.githubusercontent.com/54228342/199519940-ceed23b1-953a-4859-bc09-5c53781a2f36.png)

- Создадим пустой объект и назовем его MainMenu. Создадим скрипт и дадим ему аналогичное название, после чего повесим его на пустой объект. Сам скрипт будет выглядеть следующим образом.

```c#

using UnityEngine;
using UnityEngine.SceneManagement;

public class MainMenu : MonoBehaviour
{
    public void PlayGame()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex + 1);
    }

    public void QuitGame()
    {
        Application.Quit();
    }
}

```

- Создадим 3 кнопки для начала игры, настроек и выхода, Сделаем их дочерними для объекта MainMenu, при этом данный объект должен находиться в Canvas. Настроим кнопкам нужные названия, текс, размер шрифта и положение на экране. Каждой кнопке присваиваем спрайт облаков из последнего ассета в Source Image компонента Image.
- Последним шагом будет настроить функционал этим кнопкам. В компоненте Button объекта PlayButton внутри окна On Click() нажимаем на +, в пустую ячейку добавляем объект MainMenu. После этого нажимаем No function > MainMenu > PlayGame(). Данная кнопка будет активировать метод PlayGame() скрипта MainMenu.

![image](https://user-images.githubusercontent.com/54228342/199526718-5830af64-bd82-4131-b9b6-a5a647e2f247.png)

- В билде проекта добавляем игровую сцену.

![image](https://user-images.githubusercontent.com/54228342/199527456-867fade3-309f-45d2-b3d4-49f82584d8f6.png)

- Теперь можно посмотреть на рабочее стартовое меню и работу кнопки.

![Видео 02-11-2022 201356](https://user-images.githubusercontent.com/54228342/199527898-e9b2ca7e-012d-4810-ab08-2e3a34fb1430.gif)

- В третьем видео мы будем дорабатывать функционал стартового меню, и сделаем возможность поставить игру на паузу и выйти на главноый экран.
- Добавим кнопке выхода из игры метод Quit() по такой же схеме, как и с кнопкой начала игры.
- Скопируем объект MainMenu, назовем его SettingMenu. В нем кнопку QuitButton переименуем в BackButton. Перепишем текст кнопки на "BACK". Удалим все прочие кнопки. В окне On Click() кнопки сделаем, как на скриншоте.

![image](https://user-images.githubusercontent.com/54228342/199531802-da4bd2de-64ef-492c-8b2f-edfac663aa2c.png)

- Для кнопки OptionButton объекта MainMenu сделаем тоже самое, но поменяем местами галочку. Объект SettingMenu изначально должен быть выключен. Для этого слева от названия объекта нужно убрать галочку.

![image](https://user-images.githubusercontent.com/54228342/199532832-1d6dcbe1-4e2b-4a08-ad56-7876085f114c.png)
![image](https://user-images.githubusercontent.com/54228342/199532903-e449117d-2133-4205-8fbc-50e32a890596.png)

- Перейдем на сцену игры, создадим скрипт Pause и поместим его на MainCamera. В скрипт запишем следующее.

```c#

using UnityEngine;
using UnityEngine.SceneManagement;

public class Pause : MonoBehaviour
{
    private bool paused = false;
    public GameObject panel;

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            if (!paused)
            {
                Time.timeScale = 0;
                paused = true;
                panel.SetActive(true);
            }
            else
            {
                Time.timeScale = 1;
                paused = false;
                panel.SetActive(false);
            }
        }

        if (Input.GetKeyDown(KeyCode.Escape))
            SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex - 1);
    }
}

```

- Cоздадим текст, назовем его Pause. В самом тексте напишем "Paused". Настроим размер и цвет шрифта, а также расположение текста на экране. Добавим объекту якорь. Изначально сделаем его неактивным и добавим его в пустую ячейку последнего созданного скрипта. Данный текст будет появляться, если игра стоит на паузе.
- Теперь посмотрим на результаты работы после просмотра третьего видео.

![Видео 02-11-2022 205606](https://user-images.githubusercontent.com/54228342/199538783-35a795b5-138b-4b42-8ed7-742e93a03200.gif)

- Следующий шаг: поработаем с музыкой и звуками для игры. В первую очередь добавим, установим и импортируем новый ассет со звуками "Free Orchestral Music Pack". 
- На сцене стартового меню объекту MainCamera добавим комопнент Audio Source. Добавим аудиофайл "Aspiration Woods" в папку _AudioFiles и в этот компонент. Поставим галочки напротив Play On Awake и Loop. Такие же действия совершим в сцене самой игры, но уже с аудиофайлом "Final Struggle". После удалим папку ассета, она нам больше не понадобится.

![image](https://user-images.githubusercontent.com/54228342/199549078-7df1af5a-382e-482b-8ab2-1e421ca19145.png)

- Поработаем теперь со следующим ассетом, в котором уже будут звуковые эффекты: "Grenade Sound FX". После импорта его в проект перенесем файл Grenade2Short в папку _AudioFilesи переименуем его в DragonEggExplosion. После чего совершаем знакомые действия в префабе DragonEgg - добавляем компонент AudioSource, в него добавляем наш новый аудиофайл, и убираем галочку напротив Play On Awake.
- Зайдем в скрипт DragonEgg и добавим в него несколько строчек для работы аудиофайла.

```c#

public class DragonEgg : MonoBehaviour
{
    public static float bottomY = -30f;
    public AudioSource audioSource; // new

    private void OnTriggerEnter(Collider other)
    {
        ParticleSystem ps = GetComponent<ParticleSystem>();
        var em = ps.emission;
        em.enabled = true;

        Renderer rend = GetComponent<Renderer>();
        rend.enabled = false;

        audioSource = GetComponent<AudioSource>(); // new
        audioSource.Play(); // new
    }
    
    ...

```

- Возьмем из ассета файл Impact on Snow, переименуем его в DragonEggImpact, перенесем его в папку с нашими аудифайлами. Сделаем все по такой же схеме, как и с прошлым аудиофайлом, но теперь в префабе EnergyShield. В скрипт EnergyShield добавим некоторые строчки кода.

```c#

public class EnergyShield : MonoBehaviour
{
    public TextMeshProUGUI scoreGT;
    public AudioSource audioSource; // new
    
    ...
    
    private void OnCollisionEnter(Collision collision)
    {
        GameObject collided = collision.gameObject;
        if (collided.tag == "Dragon Egg")
            Destroy(collided);

        int score = int.Parse(scoreGT.text);
        score += 1;
        scoreGT.text = score.ToString();

        audioSource = GetComponent<AudioSource>(); // new
        audioSource.Play(); // new
    }
}

```

- Теперь можем проверить, что все звуки и музыка работают на каждой сцене.

https://user-images.githubusercontent.com/54228342/199641735-81fa0051-391d-4ff8-b399-3644e1adfc3e.mp4

- Начнем подготавливать проект к выпуску на сервис, поэтому удалим лишние папки ассетов. Удаляем папку Grenade Sound FX и StreamingAssets. Из папки Painted HQ 2D Forest Medieval Background перенесем текстуры облаков, которые мы использовали для кнопок главного меню, в папку _Textures, после чего удаляем папку ассета.
- Добавим в нашу игру персонажа, который якобы стоит и управляет шаром, которым мы ловим яйца. Зайдем на сайт Mixamo.com, выберем подходящего персонажа и анимацию для него, после чего скачаем его классическими настройками.

![image](https://user-images.githubusercontent.com/54228342/199644007-eca203f9-403d-4221-a98f-7e6b78232d95.png)
![image](https://user-images.githubusercontent.com/54228342/199644019-707ccd8d-16fa-42a0-ab09-49e140696dc7.png)

- скачанный файл перенесем в проект в папку _Prefabs и добавим его на игровую сцену. Переименуем префаб на имя персонажа "Abe". Настроим его положение и размер, чтобы персонажа было хорошо видно, и он не мешал основному геймплею.

![image](https://user-images.githubusercontent.com/54228342/199644806-fd1b3dd5-f417-4c44-b5d1-9cb1e030b3cf.png)

- Распакуем текстуры для нашего персонажа. Нажимаем на его префаб. В инспекторе Нажимаем вкладку Materials > Extract Textures... > выбираем папку _Textures, в ней создаем папку Abe и выбираем ее. Текстуры загрузятся туда и появятся автоматически на персонаже в сцене. В выплывшем окне выбираем Fix now.

![image](https://user-images.githubusercontent.com/54228342/199645398-79586bc8-8554-4b8d-b6c2-a99cb63c6b40.png)

- Раскроем префаб персонажа, найдем файл анимации и скопируем его.

![image](https://user-images.githubusercontent.com/54228342/199645651-8b97d267-e9ee-4294-aa2b-f8286db38542.png)

- Переименуем его в AbeAnimation. В инспеткоре поставим галочку напротив Loop Time и перенесем анимацию в папку с анимациями.
- В папке создадим новый Animator Controller и назовем его AbeCTRL. В него добавим только что созданную анмиацию. После этого контроллер добавляем персонажу на сцене через окно иерархии.

![image](https://user-images.githubusercontent.com/54228342/199646113-f170c472-3ae3-48ff-a906-0a97610dab22.png)

- Далее создадим на сцене Point Light.

![image](https://user-images.githubusercontent.com/54228342/199646813-ca64e483-5323-409d-be1f-961f5dd685c4.png)

- Настроим его рядом с персонажем, чтобы он светил цветом нашего энергетического щита. Тогда через анимацию и освещение будет поялвляться ассоциация, что наш персонаж управляет этим щитом.

![image](https://user-images.githubusercontent.com/54228342/199646984-387106fb-f9f5-4a0f-b9ed-b9dd6c099a83.png)

- По завершению пятого видео мы избавились от лишних папок и добавили в игру персонажа. Теперь можно посмотреть, как будет выглядеть игра.

![Видео 03-11-2022 092822](https://user-images.githubusercontent.com/54228342/199647776-f914b409-f2c5-4e20-98f5-0c3eb1df4d79.gif)

## Задание 2
### Привести описание того, как происходит сборка проекта под другие платформы. Какие могут быть особенности?

Ход работы:

- В этом задании я расскажу все, что знаю сам о создании сборки проекта на разные платформы и о некоторых особенностях данного процесса.
- Для того, чтобы создать сборку проекта на какую-либо платформу в Unity, нужно в верхнем левом углу нажать на кнопку File > Build Settings...

![image](https://user-images.githubusercontent.com/54228342/199648836-390b13fc-8d2c-49a4-afaf-0320b88caebb.png)

- После этого откроется окно Build Settings.

![image](https://user-images.githubusercontent.com/54228342/199648969-469b2774-1ae1-4b39-bb57-4b461697c738.png)

### 1. Окно сцен
![image](https://user-images.githubusercontent.com/54228342/199649771-db646009-e0ac-48f5-9a06-65c9902984d2.png)

- В верхней части экрана находится окно Scenes In Build. Тут показываются сцены, которые будут находится в сборке. Сцены будут показаны как путь - название папки, в которой находится сцена/Название самой сцены. 
- Слева от пути можно будет поставить или убрать галочку. В сборку пойдут лишь те сцены, которые помечены галочкой. Справа от пути будет находится индекс сцены. Отсчет индексов начинается с нуля. Если сцены добавлены в сборку, то в скриптах к ним можно будет обращаться не только через название, но и через этот индекс. 
- Если нажать на кнопку Add Open Scenes, то откроется сцена, которая открыта в данный момент в Unity. Чтобы добавить несколько сцен сразу, можно будет просто выделить все нужные и перенести их в это окно зажатой левой кнопкой мыши.
- Чтобы удалить сцену из сборки, нужно нажать правой кнопкой мыши на нужную сцену в окне, либо выделить несколько, и выбрать Remove Selection или нажать кнопку Del на клавиатуре.

### 2. Окно платформ
![image](https://user-images.githubusercontent.com/54228342/199651553-32482bdd-d65b-44da-a9ba-24aafd9839ad.png)

- Слева будет находится окно Platform, в котором будут даны на выбор разные платформы, которые можно выбрать. Именно на выбранной платформе будет корректно работать весь функционал сборки.
- Справа от названия выбранной платформы будет виден значок Unity(например, как на скриншоте напротив WebGL). Более светлые значки платформ показывают, что модуль уже загружен и проект можно переключать на данную платформу. Если же значки серые, то требуется установка модуля. Сделать это можно, выбрав нужную платформу и нажав кнопку Install with Unity Hub. Для платформ PS4 и PS5 нужно иметь определенную лицензию.

![image](https://user-images.githubusercontent.com/54228342/199652826-cb71939c-3008-49f9-b154-9cd383329873.png)

- После установки модуля появятся настройки для самой платформы правее окна Platform. У каждой платформы свои индивидуальные настройки. Лично я никогда этими настройками не пользовался, так как не пригождалось, но они понадобятся тем, кому нужно бдует более тонко настроить свою сборку.

### 3. Нижняя часть окна Build Settings.
![image](https://user-images.githubusercontent.com/54228342/199654104-f9f7d37d-a7c7-445e-bf47-0536fbf7f1fa.png)

- После того, как все сцены добавлены и платформа выбрана, остается совершить последние настройки самой сборки и построить ее. 
- Взглянем сначала на левую часть экрана. Там находится небольшое окно Asset Import Overrides. Оно нужно для настроек текстур в проекте. Данное окно рекомендуется использовать только во время разработки для переключения между платформ. Изначально настройки отключены и текстуры не будут тронуты.
- Первая настройка Max Texture Size позволит ограничить максимальное разрешение для текстур, чтобы сократить время импорта текстур.

![image](https://user-images.githubusercontent.com/54228342/199656551-714cc9ea-786f-47b5-93d2-fda593174f46.png)

- Вторая настройка Texture Compression позволяет сжать текстуры в другой формат(Force Fast Compressor - импорт происходит быстрее, но теряется качество текстур), либо использовать несжатые форматы(Force Uncompressed - импорт происходит быстрее, но полученные текстуры будут занимать больше памяти).

![image](https://user-images.githubusercontent.com/54228342/199656583-a3a7a918-7fd2-435a-8ba9-0db2804af9f3.png)

- Ниже под этим окном находится кнопка Player Settings, которая отправляет нас в меню настроек сборки.

![image](https://user-images.githubusercontent.com/54228342/199657857-7f29e943-df42-46a8-8442-af582c35d556.png)

- Сверху можно настроить Название компании и продукта, а так же его версию и иконку. Ниже идут более узкие настройки для сборки под определенные платформы. Настроек очень много для каждой из платформ, поэтому не стоит разбирать их, так как это займет очень много времени.
- Вернемся к нижней части окна Build Settings, и посмотрим на правую часть. Там находятся 2 кнопки. Если нужная нам платформа не выбрана, тогда кнопка будет называться Switch Platform. Она переключит наш проект под выбранную платформу. Чтобы переключиться на другую платформу, понадобится некоторое время.
- Если проект уже перенесен на нужную нам платформу, тогда вместо кнопки Switch Platform будет кнопка Build. Также будет подсвечена кнопка Build and Run.

![image](https://user-images.githubusercontent.com/54228342/199659476-7bcc399d-274d-421e-aad3-3cb7ee400efc.png)

- Кнопка Build создает сборку под выбранную платформу со всеми выбранными настройками. Послее нажатия нужно будет выбрать папку, куда будут помещены все файлы сборки. Однако, у платформ есть особенность: чтобы можно было сделать рабочую сборку, придется установить определенные модули для версии Unity, в которой создан проект(Например, для платформы Android нужно добавить модуль Android Build Support, который содержит в себе Android SDK, NDK Tools и OpenJDK, чтобы можно было создавать .apk файлы, работающие на данной платформе. Для браузерной игры нужен WebGL Build Support, и так далее). Сделать это можно в Unity Hub.

![image](https://user-images.githubusercontent.com/54228342/199660629-3f1ca71a-0771-4398-b7ac-864ea96b850e.png)

- На создание сборки так же понадобится какое-то количество времени. После завершения в папке будут находится все нужные файлы и приложение можно будет запустить на своей платформе и поиграть.
- Кнопка Build And Run так же создаст сборку со всеми настройками и сразу запустит проект на своей платформе. 
- Над этими двумя кнопками расположена ссылка Learn about Unity Cloud Build. Она направит на облачный игровой сервис Unity.

## Задание 3
### Добавить в меню Option возможность изменения громкости (от 0 до 100%) фоновой музыки в игре.

Ход работы:



## Выводы
